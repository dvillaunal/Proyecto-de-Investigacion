---
title: "Modelo Poisson"
---

## Librerias necesarias

```{python}
import pandas as pd
from matplotlib import pyplot as plt
import numpy as np
import seaborn as sns
from patsy import dmatrices
import statsmodels.api as sm
import warnings
plt.style.use('ggplot')
```

# Introducción

Se presenta el reporte detallado que corresponde al mes de marzo, este documento tiene como objetivo aplicar técnicas estadísticas avanzadas para analizar los datos de graduados y otras variables relevantes como sector, metodología, área de conocimiento, semestre de la IES y otras variables que distinguen aun más los grupos como el sexo, año para tener unos conteos que son demanda real (inscritos), admitidos, demanda potencial (graduados).

Siguiendo con la idea de los otros informes contamos con la agrupación de las bases de datos donde se eliminan variables que se cree que no aportan a la creación de modelos de predicción como el conteo de los matriculados, como el nombre de la institución (demasiados nombres que afectarían el modelo).

El tratamiento de los datos y la creación de los modelos respectivos está hecha en python.

# Lectura de los datos

Se leen los datos de la agrupación total que contiene:

- n° de inscritos
- n° de admitidos
- n° de graduados

```{python}
ruta = "/home/daniel/OneDrive/Documentos (OneDrive-UNAL)/pro_inv/Proyecto-de-Investigacion/Analisis_Marzo/BD_agrupada.xlsx"

df0 = pd.read_excel(ruta)
df0['ano'] = df0['ano'].astype("category")
```

Antes de analizar los datos, necesitamos observar que el conteo a utilizar como variable de respuesta $Y$ cumplan con el supuesto que la media (nuestro parametro $\lambda$) sea constante, es decir que los valores varien frente a una valor

```{python}
# Columnas a cosiderar
v = list()
for i in [0,1,2,3,5,6,7,8,9]:
    v.append(list(df0.columns.values)[i])

# Nueva BD agrupando por nyear
df = df0[v].groupby(['ano', 'sector_ies', 'sexo', 'area_de_conocimiento'], as_index=False)[v[6:9]].agg(np.sum)
```

Una vez se agruparon los datos por las variables pertinetes tenemos que nuestra nueva BD es:

```{python}
df.head(5)
```

Ahora se precede a graficar los datos del conteo de la variable de respuesta (demanda potencial) por algún tipo de varible a agrupar, en este caso se toma por sexo según el caracter de la IES.

```{python}
# Serie de tiempo de los datos de Demanda potencial
ax = sns.relplot(kind='line', data=df, x = 'ano', y = 'demanda_potencial', hue='sexo',col='sector_ies', errorbar=None)
ax.tick_params(axis='x', rotation=45)
plt.show()
```

Se puede notar que en los dos casos ninguno cuenta con media constante.

por lo cual esto puede ser un factor que afecte las predicciones ya que los datos a modelar cuentan con una tendencia crecienciente.

# Partición de los datos

se crean los datos de entramiento y test de los datos, teniendo en cuenta que estos se parten de forma secuencial, se toma el 80% de los datos de arriba hacia abajo dejando el 20% al conjunto de testeo.

```{python}
df_train = df.iloc[0:384,:]
df_test = df.iloc[384:480,:]
print('Training data set length='+str(len(df_train)))
print('Testing data set length='+str(len(df_test)))
```

Ahora creamos la formula para aplicar al modelo:

```{python}
expr = "demanda_potencial~ano+sector_ies+sexo+area_de_conocimiento+demanda_real+admitidos"

# One-hot encoding
y_train, X_train = dmatrices(expr, df_train,return_type='dataframe')
y_test, X_test = dmatrices(expr, df_test, return_type='dataframe')
```


Se ajusta el modelo con las matrices de diseño creadas:

```{python}
poisson_training_results = sm.GLM(y_train, X_train, family=sm.families.Poisson()).fit()

print(poisson_training_results.summary())
```

# Predicciones

```{python}
poisson_predictions = poisson_training_results.get_prediction(X_test)

poisson_predictions2 = poisson_training_results.get_prediction(X_train)

#summary_frame() returns a pandas DataFrame
predictions_summary_frame = poisson_predictions.summary_frame()

rmse_test = np.sqrt(np.sum((poisson_predictions.predicted_mean-y_test.demanda_potencial.to_numpy())**2)/192)

print("RMSE de test: ",rmse_test)

rmse_train = np.sqrt(np.sum((poisson_predictions2.predicted_mean-y_train.demanda_potencial.to_numpy())**2)/768)

print("RMSE de train: ",rmse_train)

print("Error de Predicción: ",rmse_train-rmse_test)

print(predictions_summary_frame)
```

## Verificación de los valores reales vs los predichos

```{python}
#Mlot the predicted counts versus the actual counts for the test data.
predicted_counts=predictions_summary_frame['mean']
actual_counts = y_test['demanda_potencial']
fig = plt.figure()
fig.suptitle('Predichos vs Reales sobre el N° de graduados')
actual, = plt.plot(X_test.index, actual_counts, 'go-', label='Actual counts')
predicted, = plt.plot(X_test.index, predicted_counts, 'ro-', label='Predicted counts')
plt.legend(handles=[predicted, actual])
plt.show()
```


## Grafico de puntos reales vs predichos

```{python}
# Linear regression
m, b = np.polyfit(actual_counts, predicted_counts, 1)
#Show scatter plot of Actual versus Predicted counts
fig, ax = plt.subplots(figsize=(7, 7))
plt.ylim([0, 50000])
plt.xlim([0, 50000])
ax.scatter(y=predicted_counts, x=actual_counts, marker='.', color = "blue")
ax.plot((0, 1), (0, 1), color = "gray", transform=ax.transAxes, ls = '--', label="1:1 line")
ax.plot(actual_counts, m*actual_counts+b, color = "red", label = "regression fitted line")
ax.set(xlabel ="Observed counts", ylabel = "Predicted counts",
       title="Scatter plot of Observed versus Predicted counts")
plt.legend()
plt.show()
```

## Grafico de predicciones vs observados por año

```{python}
warnings.filterwarnings("ignore")
# Nuevo data frame agrupando por año
dfa = pd.DataFrame({'anio': df.ano[384:480],
              'observados': df.demanda_potencial[384:480],
              'predicciones':predicted_counts}).groupby('anio', as_index=False)['observados', 'predicciones'].agg(np.sum)

# Quitar observaciones con cero:
mask = (dfa['observados'] == 0) | (dfa['predicciones'] == 0)
dfa = dfa.loc[~mask]

# Pivot longer de dfa
dfa = pd.melt(dfa, id_vars = 'anio', value_vars=['observados', 'predicciones'])
dfa.rename(columns= {'variable': 'demanda_potencial', 'value': 'n_graduados'}, inplace=True)
dfa['n_graduados'] = np.round(dfa['n_graduados'], 3)


# Grafico de Predicciones vs Observaciones por año
ax = sns.lineplot(data=dfa, x = 'anio', y = 'n_graduados', hue='demanda_potencial',
                  style = 'demanda_potencial', errorbar=None, markers=True)
ax.tick_params(axis='x', rotation=45)
plt.xlabel('Año')
plt.ylabel('N° de Graduados')
plt.xticks(dfa.anio)
plt.show()
```